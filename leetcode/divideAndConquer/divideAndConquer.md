# 📖 분할 정복(Divide and Conquer) 이론 정리

## 1. 개념 정의

**분할 정복(Divide and Conquer)** 은 큰 문제를 **작은 하위 문제들로 분할(Divide)** 하고, 각 하위 문제를 독립적으로 **정복(Conquer)** 한 후, 그 결과를 다시 **합쳐서(Combine)** 원래 문제를 해결하는 알고리즘 설계 기법이다.

---

## 2. 주요 단계

분할 정복 알고리즘은 일반적으로 다음 세 단계로 구성된다:

1. **Divide (분할)**

   - 주어진 문제를 더 작은 하위 문제들로 쪼갠다.
   - 보통 문제의 크기를 절반 정도로 나누는 경우가 많다.

2. **Conquer (정복)**

   - 분할된 하위 문제들을 재귀적으로 해결한다.
   - 충분히 작아져서 더 이상 나눌 수 없는 경우(=기저 조건, Base Case) 직접 답을 구한다.

3. **Combine (결합)**
   - 하위 문제의 해답을 모아 원래 문제의 최종 해답을 만든다.

---

## 3. 시간 복잡도 분석 (마스터 정리)

분할 정복의 시간 복잡도는 **재귀 관계식**으로 표현된다:

\[
T(n) = a \cdot T\left(\frac{n}{b}\right) + f(n)
\]

- \(n\): 문제 크기
- \(a\): 분할되는 하위 문제의 개수
- \(b\): 하위 문제 크기를 줄이는 비율
- \(f(n)\): 분할과 결합에 드는 비용

### 마스터 정리 (Master Theorem)

1. **Case 1**: \(f(n) = O(n^{\log_b a - \epsilon})\) 이면,  
   \[
   T(n) = \Theta(n^{\log_b a})
   \]

2. **Case 2**: \(f(n) = \Theta(n^{\log_b a} \cdot \log^k n)\) 이면,  
   \[
   T(n) = \Theta(n^{\log_b a} \cdot \log^{k+1} n)
   \]

3. **Case 3**: \(f(n) = \Omega(n^{\log_b a + \epsilon})\) 이고, 정규성 조건이 만족되면  
   \[
   T(n) = \Theta(f(n))
   \]

---

## 4. 대표적인 예시

- **정렬**

  - Merge Sort (병합 정렬) → \(O(n \log n)\)
  - Quick Sort (퀵 정렬) → 평균 \(O(n \log n)\), 최악 \(O(n^2)\)

- **탐색**

  - Binary Search (이진 탐색) → \(O(\log n)\)

- **행렬 곱셈**

  - Strassen 알고리즘 → \(O(n^{2.81})\)

- **기타**
  - FFT (고속 푸리에 변환)
  - 최근접 점(Pair of Closest Points) 문제

---

## 5. 장단점

### ✅ 장점

- 복잡한 문제를 단순한 작은 문제로 나눌 수 있음
- 재귀 구조로 구현이 직관적임
- 병렬화(parallelization)가 용이

### ❌ 단점

- 중복된 하위 문제가 발생할 수 있음 (→ 이럴 땐 **DP**가 더 적합)
- 재귀 호출로 인한 오버헤드 존재
- 결합 단계(Combine)가 비효율적일 경우 전체 성능 저하

---

## 6. 분할 정복 vs 동적 계획법(DP)

| 구분               | 분할 정복 (Divide & Conquer)          | 동적 계획법 (Dynamic Programming)  |
| ------------------ | ------------------------------------- | ---------------------------------- |
| **부분 문제 성격** | 서로 독립적 (Disjoint)                | 중복되는 문제 (Overlapping)        |
| **핵심 아이디어**  | 쪼개서 해결 후 합친다                 | 결과를 저장하여 재활용한다         |
| **대표 예시**      | Merge Sort, Quick Sort, Binary Search | Fibonacci, Knapsack, Shortest Path |

---

👉 결론적으로, **분할 정복은 큰 문제를 나누어 풀고 합치는 방법론**이고,  
**DP는 중복되는 부분 문제를 효율적으로 처리하는 확장 개념**이라고 할 수 있다.
