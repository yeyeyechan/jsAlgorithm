## 기본 풀이 (공간복잡도 O(n))

```js
var sortList = function (head) {
  const list = [];
  if (head === null) return null;
  while (head) {
    list.push(head.val);
    head = head.next;
  } //O(n)
  list.sort((a, b) => a - b); //nlog(n)

  const result = new ListNode(list[0]);

  list.slice(1).reduce((node, val) => {
    node.next = new ListNode(val);
    return node.next;
  }, result);
  return result;
};
```

## 배열을 이용한 탑다운 구현

```js
var sortList_2 = function (head) {
  const list = [];
  if (head === null) return null;

  // 1. 연결 리스트 → 배열
  while (head) {
    list.push(head.val);
    head = head.next;
  }

  // 2. 병합 정렬
  function mergeSort(arr) {
    if (arr.length <= 1) return arr; // 수정: arr 반환
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    return merge(left, right);
  }

  function merge(left, right) {
    let i = 0,
      j = 0; // 수정: 둘 다 0으로 초기화
    const result = [];

    while (i < left.length && j < right.length) {
      if (left[i] < right[j]) {
        result.push(left[i]);
        i++;
      } else {
        result.push(right[j]);
        j++;
      }
    }
    // 남은 원소 붙이기
    return result.concat(left.slice(i)).concat(right.slice(j)); // 수정: return 추가
  }

  const sorted = mergeSort(list);

  // 3. 배열 → 연결 리스트
  const result = new ListNode(sorted[0]);
  sorted.slice(1).reduce((node, val) => {
    node.next = new ListNode(val);
    return node.next;
  }, result);

  return result;
};
```

## 배열을 이용한 bottom up

```js
var sortList_3 = function (head) {
  const list = [];
  if (head === null) return null;

  // 1. 연결 리스트 → 배열
  while (head) {
    list.push(head.val);
    head = head.next;
  }

  // 2. 병합 정렬
  function mergeSort(arr) {
    if (arr.length <= 1) return arr; // 수정: arr 반환
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    return merge(left, right);
  }

  function merge(left, right) {
    let i = 0,
      j = 0; // 수정: 둘 다 0으로 초기화
    const result = [];

    while (i < left.length && j < right.length) {
      if (left[i] < right[j]) {
        result.push(left[i]);
        i++;
      } else {
        result.push(right[j]);
        j++;
      }
    }
    // 남은 원소 붙이기
    return result.concat(left.slice(i)).concat(right.slice(j)); // 수정: return 추가
  }

  const sorted = mergeSort(list);

  // 3. 배열 → 연결 리스트
  const result = new ListNode(sorted[0]);
  sorted.slice(1).reduce((node, val) => {
    node.next = new ListNode(val);
    return node.next;
  }, result);

  return result;
};
```
